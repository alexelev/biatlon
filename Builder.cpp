#include "protos.h"

/*
	Конструктор по умолчанию
*/
Builder::Builder() {
}

///*
//	Для открытия файла на чтение/дозапись
//*/
//Builder::Builder(string path) {
//	if (path != "") {
//		fin.open(path);
//		if (fin.is_open()) {
//			fin.seekg(0, ios::end);
//			set_filesize(fin.tellg());
//			fin.seekg(0, ios::beg);
//		}
//	}
//}

///*
//	Для установки размера файла
//*/
//void Builder::set_filesize(ulong bytes) {
//	if (bytes != NULL) {
//		filesize = bytes;
//	}
//}

/*
	Деструктор
*/
Builder::~Builder() {
	fin.close();
	fout.close();
}

///*
//	Для применения в случае, когда был использован конструктор без параметров
//*/
//void Builder::read(string path) {
//	fin.open(path);
//	if (fin.is_open()) {
//		parser->parse_header(get_first_line());
//		parser->parse_footer(get_last_line());
//
//		fin.close();
//	}
//}

///*
//	Для применения в случае создания объекта с помощью конструктора с
//	параметром
//*/
//void Builder::read() {
//	if (fin.is_open()) {
//		parser->parse_header(get_first_line());
//		parser->parse_footer(get_last_line());
//		fin.close();
//	}
//}

// Для получения первой строки обрабатываемого файла
string Builder::get_first_line()
{
	string buffer = "";
	fin.open(path);
	if (fin.is_open()) {
		fin.seekg(0, ios::beg);
		getline(fin, buffer);
	}
	fin.close();
	return buffer;
}


/*
	Для получения последней строки обрабатываемого файла
	использован материал ответа на вопрос http://stackoverflow.com/questions/11876290/c-fastest-way-to-read-only-last-line-of-text-file
*/
string Builder::get_last_line()
{
	string buffer = "";
	fin.open(path);
	if (fin.is_open()) {
		// перемещаемся на позицию перед концом файла
		fin.seekg(-1, ios_base::end);

		bool keepLooping = true;
		while (keepLooping) {
			char ch;
			// Получаем текущий символ из файла
			fin.get(ch);

			if ((int)fin.tellg() <= 1) {
				// если указатель файла оказался перед нолевым символом
				// то первая строка будет одновременно и последней
				fin.seekg(0, ios::beg);
				// и дальше не стоит выполнять цикл
				keepLooping = false;
			}
			else if (ch == '\n') {
				// If the data was a newline
				// если текущий символ является символом перевода строки
				// оставляем указатель на текущей позиции
				keepLooping = false;
			}
			else {
				// в противном случае
				// перемещаем указатель на символ перед текущим
				fin.seekg(-2, ios_base::cur);
			}
		}
		// после отработки цикла указатель в файле будет стоять установлен
		// либо на начало файла, либо на последний символ перевода строки
		getline(fin, buffer);
	}
	fin.close();
	return buffer;
}

/*
	Для получения кол-ва строк в файле
*/
uint Builder::get_numberof_lines() {
	uint count = 0;
	fin.open(path);
	if (fin.is_open()) {
		string buffer;
		fin.seekg(0, ios::beg);
		while (getline(fin, buffer)) {
			count++;
		}
		fin.close();
		return count;
	}
	fin.close();
	return NULL;
}

void Builder::load_data(string path, DStore<Biatlonist> &sportsmen)
{
	this->path = path;
	// проверка заголовока
	string header = get_first_line();
	parser->parse_header(header);
	// проверка подвала
	string footer = get_last_line();
	parser->parse_footer(footer);

	uint numberof_lines = get_numberof_lines();
	uint fact_lines = numberof_lines - 2;

	parser->validator->set_fact_records(fact_lines);

	fin.open(path);
	if (fin.is_open()) {

		if (parser->validator->is_start_valid()) {
			// построчное чтение и передача на разбор
			uint cur_line = 1;
			string buffer;
			uint i = 0;

			while (i++ < cur_line) {
				getline(fin, buffer);
			}

			while (cur_line++ <= fact_lines) {
				getline(fin, buffer);
				DStore<string> set = parser->split(buffer);
				string cur_schema = parser->get_schema(set);
				if (parser->validator->is_format_valid(cur_schema)) {
					parser->parse(set, sportsmen);
				}
				else {
					Logger::invalid_format(cur_line - 1);
					break;
				}
			}

			uint cur_total_misses = 0;
			for (size_t i = 0, size = sportsmen.get_size(); i < size; i++)
			{
				cur_total_misses += sportsmen.at(i).get_total_misses();
			}

			if (!parser->validator->is_misses_valid(cur_total_misses)) {
				Logger::invalid_total_misses();
			}
		}
		else {
			Logger::invalid_start_validation();
		}
		fin.close();
	}
	else {
		Logger::invalid_phisycal_state();
	}

}

void Builder::save_data(string path, const DStore<Biatlonist> &data)
{
	fout.open(path, ios::out);
	if (fout.is_open()) {
		for (size_t i = 0, size = data.get_size(); i < size; i++)
		{
			fout << data.at(i);
		}
	}
	else {
		Logger::invalid_phisycal_state();
	}
}

void Builder::save_data(string path, const DStore<string> &data)
{
	fout.open(path, ios::out);
	if (fout.is_open()) {
		for (size_t i = 0, size = data.get_size(); i < size; i++)
		{
			fout << data.at(i);
		}
	}
	else {
		Logger::invalid_phisycal_state();
	}
}
